/*
 * This source file is part of the Argon project.
 *
 * Licensed under the Apache License v2.0
 *
 * The 'url' module exposes useful functionality for manipulating urls.
 *
 * url module is based upon the following RFC specifications:
 *
 * RFC 3986 Uniform Resource Identifier (URI): Generic Syntax
 * https://datatracker.ietf.org/doc/html/rfc3986
 *
*/

from "error" import TypeError

pub let __version = "@PROJECT_VERSION@"

pub let SCHEME_VALID_BYTES = b"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+-."
pub let SCHEME_WITH_PARAMS = [b"", b"ftp", b"hdl", b"prospero", b"http", b"https", b"imap", b"shttp", b"rtsp", b"rtspu", b"sip", b"sips", b"mms", b"sftp", b"tel"]

pub let USES_NETLOC = ["", "file", "ftp", "git", "git+ssh", "gopher", "http", "https", "imap", "itms-services", "mms", "nfs", "nntp", "prospero", "rsync", "rtsp", "rtsps", "rtspu", "sftp", "shttp", "snews", "svn", "svn+ssh", "telnet", "wais", "ws", "wss"]

pub let ALWAYS_SAFE_BYTES = b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-~"
pub let UNSAFE_URL_BYTES = [b"\t", b"\r", b"\n"]
pub let C0_CONTROL_OR_SPACE = b"\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f "

let INPUT_ERROR = TypeError("expected Bytes or ascii String")

func coerce_args(url, scheme) {
    if typeof(url, String) {
        url = Bytes(url)
    } elif !typeof(url, Bytes) {
        panic INPUT_ERROR
    }

    if typeof(scheme, String) {
        scheme = Bytes(scheme)
    } elif !typeof(scheme, Bytes) {
        panic INPUT_ERROR
    }

    return url, scheme
}

pub func compose(components) {
    /*
        Construct a URL from a dict as returned by parse().

        This may result in a slightly different, but equivalent URL.
        For example, if the URL originally parsed had unnecessary delimiters,
        such as ? followed by an empty query, the resulting URL will not contain the ? character.
        Nevertheless the generated URL is equivalent to the original.

        - Parameter components: Dict containing the information generated by the `parse` function.
        - Returns: A string containing the url built starting from the information contained in `components`.
    */

    var scheme = components.get("scheme").unwrap_or("")

    scheme = !scheme.endswith("://") ? scheme + "://"

    var netloc = components.get("netloc").unwrap_or("")
    if !netloc && components.contains("hostinfo") {
        var hinfo = components["hostinfo"]

        netloc = hinfo.get("host").unwrap_or("")

        if hinfo.get("port").unwrap_or(nil) != nil {
            netloc = "%s:%s" % (netloc, hinfo["port"])
        }

        var uinfo = components.get("userinfo").unwrap_or(nil)
        if uinfo != nil {
            var user = uinfo.get("user").unwrap_or("")
            var pwd = uinfo.get("password").unwrap_or("")

            if user && pwd {
                netloc = "%s:%s@%s" % (user, pwd, netloc)
            } elif user {
                netloc = "%s@%s" % (user, netloc)
            }
        }
    }

    var path = components.get("path").unwrap_or("")
    if path != "" && !path.startswith("/") {
        path = "/" + path
    }

    var params = components.get("params").unwrap_or("")
    if params != "" && !params.startswith(";") {
        params = ";" + params
    }

    var query = components.get("query").unwrap_or("")
    var fragments = components.get("fragments").unwrap_or("")

    return scheme + netloc + path + params + (query ? "?%s" % query : "") + (fragments ? "#%s" % fragments : "")
}

pub func join(base, url, fragments=true) {
    /*
        Join a base URL and a possibly relative URL to form an absolute interpretation of the latter.

        - Parameters:
          - base (String): The base URL to which the relative URL will be joined. This should be a valid absolute URL.
          - url (String): The relative or absolute URL to be joined with the base URL. If this is an absolute URL, the base URL is ignored.
        - KWParameters:
          - fragments: If false, fragment identifiers are not recognized.
        - Returns: A string containing the URL constructed from the base and url parameters.
    */

    if !base {
        return url
    }

    if !url {
        return base
    }

    base, url = coerce_args(base, url)
    b_comp := parse(base, fragments=fragments)
    bscheme := b_comp["scheme"]
    bpath := b_comp["path"]

    u_comp := parse(url, scheme=b_comp["scheme"], fragments=fragments)
    uscheme := u_comp["scheme"]
    unetloc := u_comp["netloc"]
    upath := u_comp["path"]
    uparams := u_comp["params"]

    if uscheme != bscheme {
        return url
    }

    if uscheme in USES_NETLOC {
        if unetloc {
            return url
        }

        unetloc = b_comp["netloc"]
    }

    if !upath && !uparams {
        query := u_comp["query"]
        if !query {
            query = b_comp["query"]
        }

        u_comp["netloc"] = unetloc
        u_comp["path"] = b_comp["path"]
        u_comp["params"] = b_comp["params"]
        u_comp["query"] = query

        return compose(u_comp)
    }

    base_parts := bpath.split("/")
    segments := upath.split("/")

    if upath[:1] != "/" {
        segments = base_parts + segments
    }

    resolved := []

    for var seg of segments {
        if seg == ".." {
            resolved.pop()
        } elif seg == "." {
            continue
        } else {
            resolved.append(seg)
        }
    }

    if segments[-1] in (".", "..") {
        resolved.append("")
    }

    u_comp["netloc"] = unetloc
    u_comp["path"] = resolved ? "/".join(resolved) : "/"

    return compose(u_comp)
}

pub func parse(url, scheme="", fragments=true) {
    /*
        Parses a URL and builds a dict containing the different components of the URL.

        The result dict contains the following components:
        ("scheme", "netloc", "path", "params", "query", "fragments", "userinfo", "hostinfo")

        - Parameter url: Input URL.
        - KWParameters:
          - scheme: Default addressing scheme to be used only if the URL does not specify one.
          - fragments: If false, fragment identifiers are not recognized.
        - Returns: Dict containing the different components of the URL.
    */

    var netloc = b""
    var params =  b""
    var query = b""
    var frags = b""

    url, scheme = coerce_args(url, scheme)

    url = url.ltrim(chars=C0_CONTROL_OR_SPACE)
    scheme = scheme.trim(chars=C0_CONTROL_OR_SPACE)

    var cursor
    for cursor of UNSAFE_URL_BYTES {
        url = url.replace(cursor, b"")
        scheme = scheme.replace(cursor, b"")
    }

    var idx = url.find(b":")
    if idx > 0 {
        for cursor of url[:idx] {
            if cursor not in SCHEME_VALID_BYTES {
                cursor = @invalid
                break
            }
        }

        if cursor != @invalid {
            scheme, url = url[:idx].lower(), url[idx + 1:]
        }
    }

    if url[:2] == b"//" {
        var nl_length = len(url) - 2

        for cursor of b"/?#" {
            idx = url.findbyte(2, cursor)
            if idx >= 0 && idx < nl_length {
                nl_length = idx
            }
        }

        netloc = url[2:2 + nl_length]
        url = url[nl_length + 2:]
    }

    if fragments && b"#" in url {
        url = url.split(b"#", splits=1)
        if len(url) > 1 {
            url, frags = url
        } else {
            url = url[0]
        }
    }

    if b"?" in url {
        url = url.split(b"?", splits=1)
        if len(url) > 1 {
            url, query = url
        } else {
            url = url[0]
        }
    }

    if scheme in SCHEME_WITH_PARAMS && ';' in url {
        idx = url.find(b";")
        params = url[idx + 1:]
        url = url[:idx]
    }

    return {
        "scheme": scheme.tostr(),
        "netloc": netloc.tostr(),
        "path": url.tostr(),
        "params": params.tostr(),
        "query": query.tostr(),
        "fragments": frags.tostr(),
        "userinfo": parse_uinfo(netloc),
        "hostinfo": parse_hinfo(netloc)
    }
}

func parse_hinfo(netloc) {
    var hostname
    var port

    hostname = netloc.find(b"@")
    hostname = hostname > -1 ? netloc[hostname + 1:] : netloc

    var idx = hostname.find(b":")
    if idx > -1 {
        port = hostname[idx + 1:]
        hostname = hostname[:idx]
    }

    return {
        "host": hostname.tostr(),
        "port": port?.tostr()
    }
}

func parse_uinfo(netloc) {
    var username = nil
    var password = nil

    var uinfo = netloc.split(b"@", splits=1)
    if len(uinfo) > 1 {
        uinfo = uinfo[0].split(b":", splits=1)
        if len(uinfo) > 1 {
            username, password = uinfo
        } else {
            username = uinfo[0]
        }
    }

    return {
        "user": username?.tostr(),
        "password": password?.tostr()
    }
}

pub func quote(str, safe=b"/") {
    /*
        Replace special characters in string using the %XX escape.

        - Parameter str: Input string.
        - KWParameters:
          - safe: Specifies additional ASCII characters that should not be quoted (default: '/').
        - Returns: Quoted string.
    */

    var output = []

    if typeof(str, String) {
        str = Bytes(str)
    } elif !typeof(str, Bytes) {
        panic TypeError("expected Bytes or String")
    }

    var q = quoter(safe)

    for var cursor of str {
        output.append(q(cursor))
    }

    return "".join(output)
}

pub func quote_plus(str, safe=b" ") {
    /*
        Like quote(), but also replace spaces with plus signs.

        - Parameter str: Input string.
        - KWParameters:
          - safe: Specifies additional ASCII characters that should not be quoted (default: '/').
        - Returns: Quoted string.
    */

    return quote(str, safe=safe).replace(" ", "+")
}

func quoter(safe) {
    var map = {}

    if typeof(safe, String) && safe.kind == @ascii{
        safe = safe |> Bytes
    } elif !typeof(safe, Bytes) {
        panic INPUT_ERROR
    }

    safe = Set(ALWAYS_SAFE_BYTES + safe)

    return (byte) => {
        if byte in map {
            return map[byte]
        }

        var ret = byte not in safe ? "%%%X" % byte : String::chr(byte)

        map[byte] = ret

        return ret
    }
}

pub func unquote(str) {
    /*
        Replace %XX escapes with their single-character equivalent.

        - Parameter str: Input string.
        - Returns: Unquoted string.
    */

    if typeof(str, String) && str.kind == @ascii {
        if "%" not in str {
            return str
        }

        return String::unescape(str.replace("%", "\\x"))
    } elif !typeof(str, Bytes) {
        panic INPUT_ERROR
    }

    if b"%" not in str {
        return str.tostr()
    }

    return String::unescape(str.replace(b"%", b"\\x"))
}

pub func unquote_plus(str) {
    /*
        Like unquote(), but also replace plus signs with spaces.

        - Parameter str: Input string.
        - Returns: Unquoted string.
    */

    if typeof(str, String) && str.kind == @ascii {
        return str.replace("+", " ") |> unquote
    } elif !typeof(str, Bytes) {
        panic INPUT_ERROR
    }

    return str.replace(b"+", b" ") |> unquote
}
