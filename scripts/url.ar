/*
 * This source file is part of the Argon project.
 *
 * Licensed under the Apache License v2.0
 *
 * The 'url' module exposes useful functionality for manipulating urls.
 *
 * url module is based upon the following RFC specifications:
 *
 * RFC 3986 Uniform Resource Identifier (URI): Generic Syntax
 * https://datatracker.ietf.org/doc/html/rfc3986
 *
*/

from "error" import TypeError

pub let __version = "@PROJECT_VERSION@"

pub let SCHEME_VALID_BYTES = b"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+-."
pub let SCHEME_WITH_PARAMS = [b"", b"ftp", b"hdl", b"prospero", b"http", b"https", b"imap", b"shttp", b"rtsp", b"rtspu", b"sip", b"sips", b"mms", b"sftp", b"tel"]

pub let ALWAYS_SAFE_BYTES = b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-~"
pub let UNSAFE_URL_BYTES = [b"\t", b"\r", b"\n"]
pub let C0_CONTROL_OR_SPACE = b"\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f "

let INPUT_ERROR = TypeError("expected Bytes or ascii String")

func coerce_args(url, scheme) {
    if typeof(url, String) {
        url = Bytes(url)
    } elif !typeof(url, Bytes) {
        panic INPUT_ERROR
    }

    if typeof(scheme, String) {
        scheme = Bytes(scheme)
    } elif !typeof(scheme, Bytes) {
        panic INPUT_ERROR
    }

    return url, scheme
}

pub func compose(components) {
    /*
        Construct a URL from a dict as returned by parse().

        This may result in a slightly different, but equivalent URL.
        For example, if the URL originally parsed had unnecessary delimiters,
        such as ? followed by an empty query, the resulting URL will not contain the ? character.
        Nevertheless the generated URL is equivalent to the original.

        - Parameter components: Dict containing the information generated by the `parse` function.
        - Returns: A string containing the url built starting from the information contained in `components`.
    */

    var scheme = components.get("scheme").unwrap_or("")

    scheme = !scheme.endswith("://") ? scheme + "://"

    var netloc = components.get("netloc").unwrap_or("")
    if !netloc && components.contains("hostinfo") {
        var hinfo = components["hostinfo"]

        netloc = hinfo.get("host").unwrap_or("")

        if hinfo.get("port").unwrap_or(nil) != nil {
            netloc = "%s:%s" % (netloc, hinfo["port"])
        }

        var uinfo = components.get("userinfo").unwrap_or(nil)
        if uinfo != nil {
            var user = uinfo.get("user").unwrap_or("")
            var pwd = uinfo.get("password").unwrap_or("")

            if user && pwd {
                netloc = "%s:%s@%s" % (user, pwd, netloc)
            } elif user {
                netloc = "%s@%s" % (user, netloc)
            }
        }
    }

    var path = components.get("path").unwrap_or("")
    if path != "" && !path.startswith("/") {
        path = "/" + path
    }

    var params = components.get("params").unwrap_or("")
    if params != "" && !params.startswith(";") {
        params = ";" + params
    }

    var query = components.get("query").unwrap_or("")
    var fragments = components.get("fragments").unwrap_or("")

    return scheme + netloc + path + params + (query ? "?%s" % query : "") + (fragments ? "#%s" % fragments : "")
}

pub func parse(url, &kwargs) {
    /*
        Parses a URL and builds a dict containing the different components of the URL.

        The result dict contains the following components:
        ("scheme", "netloc", "path", "params", "query", "fragments", "userinfo", "hostinfo")

        - Parameter url: Input URL.
        - KWParameters:
          - scheme: Default addressing scheme to be used only if the URL does not specify one.
          - fragments: If false, fragment identifiers are not recognized.
        - Returns: Dict containing the different components of the URL.
    */

    var scheme = kwargs?.contains("scheme") ? kwargs["scheme"] : ""
    var allow_fragments = kwargs?.contains("fragments") ? kwargs["fragments"] : true
    var netloc = b""
    var params =  b""
    var query = b""
    var fragments = b""

    url, scheme = coerce_args(url, scheme)

    url = url.ltrim(chars=C0_CONTROL_OR_SPACE)
    scheme = scheme.trim(chars=C0_CONTROL_OR_SPACE)

    var cursor
    for cursor in UNSAFE_URL_BYTES {
        url = url.replace(cursor, b"", -1)
        scheme = scheme.replace(cursor, b"", -1)
    }

    var idx = url.find(b":")
    if idx > 0 {
        for cursor in url[:idx] {
            if cursor not in SCHEME_VALID_BYTES {
                cursor = @invalid
                break
            }
        }

        if cursor != @invalid {
            scheme, url = url[:idx].lower(), url[idx + 1:]
        }
    }

    if url[:2] == b"//" {
        var nl_length = len(url) - 2

        for cursor in b"/?#" {
            idx = url.findbyte(2, cursor)
            if idx >= 0 && idx < nl_length {
                nl_length = idx
            }
        }

        netloc = url[2:2 + nl_length]
        url = url[nl_length + 2:]
    }

    if allow_fragments && b"#" in url {
        url = url.split(b"#", 1)
        if len(url) > 1 {
            url, fragments = url
        } else {
            url = url[0]
        }
    }

    if b"?" in url {
        url = url.split(b"?", 1)
        if len(url) > 1 {
            url, query = url
        } else {
            url = url[0]
        }
    }

    if scheme in SCHEME_WITH_PARAMS && ';' in url {
        idx = url.find(b";")
        params = url[idx + 1:]
        url = url[:idx]
    }

    return {
        "scheme": scheme.tostr(),
        "netloc": netloc.tostr(),
        "path": url.tostr(),
        "params": params.tostr(),
        "query": query.tostr(),
        "fragments": fragments.tostr(),
        "userinfo": parse_uinfo(netloc),
        "hostinfo": parse_hinfo(netloc)
    }
}

func parse_hinfo(netloc) {
    var hostname
    var port

    hostname = netloc.find(b"@")
    hostname = hostname > -1 ? netloc[hostname + 1:] : netloc

    var idx = hostname.find(b":")
    if idx > -1 {
        port = hostname[idx + 1:]
        hostname = hostname[:idx]
    }

    return {
        "host": hostname.tostr(),
        "port": port?.tostr()
    }
}

func parse_uinfo(netloc) {
    var username = nil
    var password = nil

    var uinfo = netloc.split(b"@", 1)
    if len(uinfo) > 1 {
        uinfo = uinfo[0].split(b":", 1)
        if len(uinfo) > 1 {
            username, password = uinfo
        } else {
            username = uinfo[0]
        }
    }

    return {
        "user": username?.tostr(),
        "password": password?.tostr()
    }
}

pub func quote(str, &kwargs) {
    /*
        Replace special characters in string using the %XX escape.

        - Parameter str: Input string.
        - KWParameters:
          - safe: Specifies additional ASCII characters that should not be quoted (default: '/').
        - Returns: Quoted string.
    */

    var output = []

    if typeof(str, String) {
        str = Bytes(str)
    } elif !typeof(str, Bytes) {
        panic TypeError("expected Bytes or String")
    }

    var q = quoter(kwargs?.contains("safe") ? kwargs["safe"] : b"/")

    var cursor
    for cursor in str {
        output.append(q(cursor))
    }

    return "".join(output)
}

pub func quote_plus(str, &kwargs) {
    /*
        Like quote(), but also replace spaces with plus signs.

        - Parameter str: Input string.
        - KWParameters:
          - safe: Specifies additional ASCII characters that should not be quoted (default: '/').
        - Returns: Quoted string.
    */

    var safe = b" "

    if kwargs?.contains("safe") {
        var _safe = kwargs["safe"]

        if typeof(_safe, String) {
            safe = Bytes(_safe) + safe
        } elif typeof(_safe, Bytes) {
            safe = _safe + safe
        }
    }

    return quote(str, safe=safe).replace(" ", "+", -1)
}

func quoter(safe) {
    var map = {}

    if typeof(safe, String) && safe.kind == @ascii{
        safe = safe |> Bytes
    } elif !typeof(safe, Bytes) {
        panic INPUT_ERROR
    }

    safe = Set(ALWAYS_SAFE_BYTES + safe)

    return (byte) => {
        if byte in map {
            return map[byte]
        }

        var ret = byte not in safe ? "%%%X" % byte : String::chr(byte)

        map[byte] = ret

        return ret
    }
}

pub func unquote(str) {
    /*
        Replace %XX escapes with their single-character equivalent.

        - Parameter str: Input string.
        - Returns: Unquoted string.
    */

    if typeof(str, String) && str.kind == @ascii {
        if "%" not in str {
            return str
        }

        return String::unescape(str.replace("%", "\\x", -1))
    } elif !typeof(str, Bytes) {
        panic INPUT_ERROR
    }

    if b"%" not in str {
        return str.tostr()
    }

    return String::unescape(str.replace(b"%", b"\\x", -1))
}

pub func unquote_plus(str) {
    /*
        Like unquote(), but also replace plus signs with spaces.

        - Parameter str: Input string.
        - Returns: Unquoted string.
    */

    if typeof(str, String) && str.kind == @ascii {
        return str.replace("+", " ", -1) |> unquote
    } elif !typeof(str, Bytes) {
        panic INPUT_ERROR
    }

    return str.replace(b"+", b" ", -1) |> unquote
}
